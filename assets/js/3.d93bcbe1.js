(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{271:function(s,t,e){s.exports=e.p+"assets/img/tcp.679add72.png"},272:function(s,t,e){s.exports=e.p+"assets/img/three-hands.f51dece1.jpg"},273:function(s,t,e){s.exports=e.p+"assets/img/four-hands.42bb38b9.png"},274:function(s,t,e){s.exports=e.p+"assets/img/cookie.744a83f2.png"},286:function(s,t,e){"use strict";e.r(t);var a=e(38),n=Object(a.a)({},function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"计算机网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络","aria-hidden":"true"}},[s._v("#")]),s._v(" 计算机网络")]),s._v(" "),a("blockquote",[a("p",[s._v("研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序")])]),s._v(" "),a("h2",{attrs:{id:"进程通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程通信","aria-hidden":"true"}},[s._v("#")]),s._v(" 进程通信")]),s._v(" "),a("p",[s._v("在操作系统中，进行通信的实际上是进程（process）而不是程序。一个进程可以被认为是运行在端系统的一个程序")]),s._v(" "),a("p",[s._v("当进程运行在相同的端系统(即同一电脑)上时，它们使用进程间的通信机制相互通信。进程间通信的规则由端系统上的操作系统确定")]),s._v(" "),a("p",[s._v("在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。发送进程生成报文并发送到网络中，接收进程接收这些报文并可能通过将报文发送回去进行响应")]),s._v(" "),a("p",[s._v("定义客户和服务器进程：在给定的一对进程之间的通信会话场景中，"),a("strong",[s._v("发起通信")]),s._v(" （即在该会话开始时发起与其他进程的联系）的进程被标识为客户，在会话开始时 "),a("strong",[s._v("等待联系")]),s._v(" 的进程是服务器")]),s._v(" "),a("p",[s._v("进程间通过套接字（socket）软件接口向网络发送或者接收报文")]),s._v(" "),a("p",[s._v("套接字是同一台主机内应用层和传输层之间的 "),a("strong",[s._v("接口")]),s._v("，由于套接字是建立网络应用程序的可编程接口，因此套接字也被称为应用程序和网络之间的应用程序编程接口（API）")]),s._v(" "),a("p",[s._v("通过 ip（主机地址） 和 port（主机中接收进程标识符）来标识进程通信中的接收进程")]),s._v(" "),a("h2",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http","aria-hidden":"true"}},[s._v("#")]),s._v(" HTTP")]),s._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[s._v("HTTP 使用 TCP 作为它的支撑运输协议")])]),s._v(" "),a("p",[s._v("Web 应用的底层协议是超文本传输协议（HyperText Transfer Protocol, HTTP），这是 Web 的核心，它定义了web客户与web服务器之间进行 http报文 交换的方式以及这些报文的结构（即如何交互和交互数据结构）")]),s._v(" "),a("p",[s._v("Web 页面由"),a("strong",[s._v("对象")]),s._v("组成，一个对象就是一个文件，该文件可以是一个 .html文件，一个 .jpg图片等等，比如：一个 Web 页面包含1个 html 基本文件和2个 css 引用文件，则这个 Web 页面包含3个对象")]),s._v(" "),a("p",[a("img",{attrs:{src:e(271),alt:"HTTP请求/响应"}})]),s._v(" "),a("ul",[a("li",[a("p",[s._v("HTTP客户首先通过发起一个与服务器的"),a("strong",[s._v("TCP连接请求")]),s._v("，一旦连接建立，该浏览器与服务器进程就可以通过套接字接口访问 TCP，然后客户和服务器从它的套接字发送或者接收 HTTP 报文")])]),s._v(" "),a("li",[a("p",[s._v("一旦客户向它的套接字发送了一个"),a("strong",[s._v("HTTP请求报文")]),s._v("，该报文就脱离了客户控制并进入 TCP 控制，由于 TCP 为 HTTP 提供可靠数据传输服务，所以在客户和服务器交换报文的过程，不必担心数据丢失")])]),s._v(" "),a("li",[a("p",[s._v("这也体现了分层体系的 "),a("strong",[s._v("最大优点")]),s._v(" ：HTTP 协议不必担心数据丢失，也不必了解 TCP 从网络的数据丢失和乱序故障中恢复的细节")])]),s._v(" "),a("li",[a("p",[s._v("HTTP 服务器 "),a("strong",[s._v("不会")]),s._v(" 保存关于客户的任何信息，所以 HTTP 是无状态协议，这意味着服务器不会因为刚刚为该用户提供了对象就不再响应，而是会重新发送该对象")])])]),s._v(" "),a("h3",{attrs:{id:"rtt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rtt","aria-hidden":"true"}},[s._v("#")]),s._v(" RTT")]),s._v(" "),a("p",[s._v("RTT指往返时间（Round-Trip Time），该时间指一个短分组从客户到服务器然后再返回客户所花费的时间")]),s._v(" "),a("p",[s._v("RTT = 分组时延 + 分组在中间路由器和交换机上的排队时延 + 分组处理时延")]),s._v(" "),a("p",[s._v("大致上说，一次 HTTP 请求/响应时间等于两次 RTT 加上服务器文件传输文件的时间")]),s._v(" "),a("h3",{attrs:{id:"http请求报文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http请求报文","aria-hidden":"true"}},[s._v("#")]),s._v(" HTTP请求报文")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 请求行，包含三个字段：请求方法，URL，HTTP版本\nPOST http://172.17.2.42/api/task/list-task-for-applicant http/1.1\n\n// 首部行\n// Host 指明了对象所在的主机，该字段提供的信息是 Web 代理高速缓存所要求的\nHost: 172.17.2.42\n\n// Connection 告诉服务器是否需要持续使用该连接，可取值 keep-alive 或者 close\nConnection: keep-alive\n\n// User-Agent 用来指明用户代理，即向服务器发送请求的浏览器类型\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3390.0 Safari/537.36\n\n// Accept-Language 表示用户想要得到该对象的语言版本\nAccept-Language: zh-CN,zh;q=0.9 \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("HTTP 请求报文的通用格式：请求行，首部行，空行，实体主体")]),s._v(" "),a("p",[s._v("HTTP 请求报文的第一行叫做请求行（request line），其后继的行叫做首部行（header line）")]),s._v(" "),a("p",[s._v("使用 GET 方法时，实体主体为空，使用 POST 方法时，才使用实体主体")]),s._v(" "),a("h3",{attrs:{id:"http响应报文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http响应报文","aria-hidden":"true"}},[s._v("#")]),s._v(" HTTP响应报文")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 状态行包含三个字段：协议版本，状态码和相应的状态信息\nHTTP/1.1 200 OK\n\n// 首部行\n// Server 指示该报文是由 nginx/1.10.1 服务器产生的\nServer: nginx/1.10.1\n\n// Date 指示服务器从它的文件系统找到该对象，插入到响应报文，并且发送该响应报文的日期和时间\nDate: Sun, 08 Apr 2018 08:47:04 GMT\n\n// Content-Type 指示了实体主体中的对象类型\nContent-Type: application/json;charset=UTF-8\n\n// Connection 告诉客户是否需要持续使用该连接，可取值 keep-alive 或者 close\nConnection: keep-alive\n\n// Last-Modified 最后修改日期和时间，对于本地客户和代理服务器上的对象缓存来说很重要\nLast-Modified: Sun, 08 Apr 2018 08:46:04 GMT\n\nentity body data...\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br")])]),a("p",[s._v("HTTP 响应报文的通用格式：状态行，首部行，空行，实体主体")]),s._v(" "),a("p",[s._v("实体主体是响应报文的主要部分，它包含了所请求的对象本身")]),s._v(" "),a("h2",{attrs:{id:"tcp连接方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接方式","aria-hidden":"true"}},[s._v("#")]),s._v(" TCP连接方式")]),s._v(" "),a("p",[s._v("客户到服务器的每个请求/响应是经单独的 TCP 连接发送，则该应用程序使用非持续连接（non-persistent connection）,每个 TCP 连接在服务器发送一个对象后关闭，即每个 TCP 连接只传输一个请求报文和一个响应报文")]),s._v(" "),a("p",[s._v("由此可见，非持续连接的缺点在于：")]),s._v(" "),a("ul",[a("li",[s._v("必须为每一个请求对象建立和维护一个全新的连接，对于每个这样的连接，在客户和服务器都要分配 TCP 的缓冲区和保持 TCP 变量")]),s._v(" "),a("li",[s._v("每个对象都要经受两倍 RTT 的交付时延")])]),s._v(" "),a("p",[s._v("客户到服务器的所有请求/响应是经相同的 TCP 连接发送，则该应用程序使用持续连接（presistent connection）。即服务器在发送响应后保持该 TCP 连接打开，在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传输")]),s._v(" "),a("p",[s._v("HTTP 在其默认方式下使用持续连接，通过 "),a("code",[s._v("Connection: keep-alive")]),s._v(" 标识")]),s._v(" "),a("h2",{attrs:{id:"三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手","aria-hidden":"true"}},[s._v("#")]),s._v(" 三次握手")]),s._v(" "),a("p",[s._v("假设客户上的一个进程想与服务器上的某一个进程建立一条连接。客户应用进程首先通知客户TCP，它希望建立一个与服务器上某个进程之间的连接。客户中的TCP会用以下方式与服务器中的TCP建立一条TCP连接")]),s._v(" "),a("p",[a("img",{attrs:{src:e(272),alt:"three-hands"}})]),s._v(" "),a("p",[s._v("客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段（SYN报文段），该报文段会被封装在一个IP数据报中，并发送给服务器")]),s._v(" "),a("ul",[a("li",[s._v("该报文段不包含应用层数据")]),s._v(" "),a("li",[s._v("报文段的首部中一个标志位（SYN比特）被置为1")]),s._v(" "),a("li",[s._v("客户会随机选择一个初始序号置于序号字段中")])]),s._v(" "),a("p",[s._v("一旦包含 TCP SYN报文段的IP数据报到达服务器，服务器就会从数据报中提取出 TCP SYN报文段，为该 TCP连接分配TCP缓存和变量，并向客户TCP 发送允许连接的报文段（SYNACK 报文段）")]),s._v(" "),a("ul",[a("li",[s._v("这个允许连接的报文段不包含应用层数据")]),s._v(" "),a("li",[s._v("报文段首部的 SYN比特 置为1")]),s._v(" "),a("li",[s._v("报文段首部的确认号被置为 （SYN报文段序号 + 1）")]),s._v(" "),a("li",[s._v("服务器选择自己的初始序号，并将其置于 TCP报文段 首部的序号字段")])]),s._v(" "),a("p",[s._v("客户接收到 SYNACK报文段之后，为该连接分配缓存和变量，并向服务器发送一个报文段")]),s._v(" "),a("ul",[a("li",[s._v("该报文段对服务器的 SYNACK报文段 进行确认，通过设置确认号为 SYNACK报文段首部的序号字段 + 1 实现")]),s._v(" "),a("li",[s._v("报文段首部的 SYN比特 置为0")]),s._v(" "),a("li",[s._v("可以在报文段负载中携带客户到服务器的数据")])]),s._v(" "),a("p",[s._v("一旦完成以上三个步骤，客户和服务器就可以相互发送包括数据的报文段了，并且在以后每个报文段，SYN比特都被置为0")]),s._v(" "),a("h2",{attrs:{id:"四次分手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四次分手","aria-hidden":"true"}},[s._v("#")]),s._v(" 四次分手")]),s._v(" "),a("p",[s._v("四次分手用于关闭 TCP 连接")]),s._v(" "),a("p",[s._v("参与一条 TCP 连接的两个进程中的任何一个都能终止该连接，当链接结束之后，客户和服务器的资源（即缓存和变量）将被释放")]),s._v(" "),a("p",[a("img",{attrs:{src:e(273),alt:"four-hands"}})]),s._v(" "),a("p",[s._v("假如某客户打算关闭连接，客户应用进程发出一个关闭连接的命令：")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("客户TCP 向 服务器发送一个特殊的 TCP报文段，这个报文段让其首部的 FIN比特 被置为1")])]),s._v(" "),a("li",[a("p",[s._v("当服务器接收到该报文段后，就向客户发送一个确认报文段")])]),s._v(" "),a("li",[a("p",[s._v("服务器主动发送它自己的终止报文段，其 FIN比特 被置为1")])]),s._v(" "),a("li",[a("p",[s._v("最终，客户对服务器的终止报文段进行确认，此时，两台主机上用于该连接的所有资源都被释放")])])]),s._v(" "),a("h2",{attrs:{id:"cookie"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie","aria-hidden":"true"}},[s._v("#")]),s._v(" Cookie")]),s._v(" "),a("p",[s._v("cookie 可以在无状态的 HTTP 之上建立一个用户会话层，允许站点对用户进行跟踪")]),s._v(" "),a("p",[s._v("cookie 技术包含四个组件：")]),s._v(" "),a("ul",[a("li",[s._v("在 HTTP 响应报文中有一个 cookie 首部行")]),s._v(" "),a("li",[s._v("在 HTTP 请求报文中有一个 cookie 首部行")]),s._v(" "),a("li",[s._v("在用户端系统中保留一个 cookie 文件，并由用户的浏览器进行管理")]),s._v(" "),a("li",[s._v("位于 Web 站点的一个后端数据库")])]),s._v(" "),a("p",[a("img",{attrs:{src:e(274),alt:"Cookie"}})]),s._v(" "),a("p",[s._v("Web 缓存器也叫代理服务器，它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体")]),s._v(" "),a("p",[s._v("在 Internet 上部署代理服务器的两个原因：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("代理服务器可以大大减少对客户请求的响应时间")])]),s._v(" "),a("li",[a("p",[s._v("代理服务器可以大大减少一个机构的接入链路到 Internet 的通信量")])])]),s._v(" "),a("p",[s._v("HTTP 协议有一种机制，允许代理服务器证实它的对象是最新的，这种机制就是条件GET方法")]),s._v(" "),a("p",[s._v("条件GET方法实现要求：")]),s._v(" "),a("ul",[a("li",[s._v("请求报文使用 GET 方法")]),s._v(" "),a("li",[s._v("请求报文中含有 If-Modified-Since 首部行")])]),s._v(" "),a("p",[s._v("代理服务器在存储响应对象的同时，也对其响应报文的 "),a("code",[s._v("Last-Modified")]),s._v(" 值进行存储，当同一对象再次被请求时，代理服务器会在请求报文中添加 "),a("code",[s._v("If-Modified-Since")]),s._v(" 字段，且其值等于之前存储的 "),a("code",[s._v("Last-Modified")]),s._v(" 的值，通过该条件GET方法告诉服务器，仅当自指定日期之后该对象被修改过，才发送此对象")]),s._v(" "),a("p",[s._v("如果响应对象未被修改，则 Web 服务器还是会向代理服务器发送响应报文，但是该响应报文中不包含所请求的对象，并且最后响应报文中，状态行为 304 Not Modified")])])},[],!1,null,null,null);t.default=n.exports}}]);