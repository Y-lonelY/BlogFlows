# Basic

> Python3 基本知识和使用

## 字符串

字符串格式化，通常有两种方式：

- 用 `%` 实现格式化
	- %d 代表整数
	- %s 代表字符串
	- %f 代表浮点数
	- %x 代表16进制整数
	- %% 代表对 % 的转义
- 通过 `format()` 实现

```python
# 用 `%` 实现格式化
str = 'hello, %s%d%.2f' %('yango', 777, 3.6666)

# format 会通过位置映射和关键字映射来找寻元素，通过 {} 来包裹关键字
str = "{server}:{}:{}".format('abc', '123', server='port') # port:abc:123
```

`str()` 用来实现字符串强制转换


## list && tuple

### list

> list 和 tuple 是 python 内置的有序集合，前者可变，后者不可变（可类比 let && const）

list 是一种有序的集合，可以随时添加或者删除元素，可类比 Array，主要方法：

```python
list = [1, 2, 3]

# 删除最后一个元素或者指定位置元素
list.pop(index)

# 向 list 中追加元素到末尾
list.append(element)

# 向 list 指定位置插入元素
list.insert(index, element)

# 返回 list 的长度
len(list)

# 字符串数组转字符串
# 对于非字符串数组，则通过遍历来进行转换
str_list = ['a', 'b', 'c']
str = ''.join(str_list)

# 通过 + 合并两个数组
new_list = list + str_list
```

### tuple

> tuple 可以看作是 list 的进化版，它拥有更强的“控制欲”，一旦tuple初始化就不能更改

需要注意的是：

- list 用 `[]`，而 tuple 用 `()`
- tuple 引用的元素不能变更，但是存在一个“陷阱”，即当其元素仍存在一个新的引用时(即嵌套引用)，可以改变二维的引用值，而不会报错
- 当tuple初始化时，如果只有一个值，此时python会以小括号来进行解释，所以此时需要添加一个逗号，来消除歧义


## 基础

优点：优雅、明确、简单、跨平台

缺点：运行速度慢，因为其是**解释型语言**，需要在代码执行时一行一行编译成CPU能够理解的机器码；代码不能加密；

适合领域

- Web网站和各种网络服务
- 系统工具和脚本
- 作为“胶水”语言将其他语言开发的模块包包装起来方便使用

不适合领域

- 贴近硬件的代码（首选为C）
- 移动开发：IOS/Android
- 游戏开发

### 基础知识

第一个python文件

在.py 文件目录下，通过命令行 `python test01.py` 来让python解释器运行当前文件代码

注意不要使用Word和Windows自带的记事本，Word保存的不是纯文本，记事本会添加字符引起编译错误

```python
# 单行注释 `# 注释内容`
# print 和 input 来控制输出和输入
# print() 遇到 “,” 会输出一个空格
print ('Hello World!')
print ('why', 'not', '?')
```

**约定用法**

- 第一行代码目的是告诉 Linux/OS X系统，这是一个python3的可执行程序，window会自动忽略
- 第二行告诉python解释器，以 utf-8 编码来读取源码
- 第四行用一个字符串来表示当前模块的注释
- 第六行通过 `__author__` 来声明作者

```python
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

'test page'

__author__ = 'yanGo'
```


### 数据类型

五种简单的数据类型

- 整数 int
- 浮点数 float
- 字符串 str
- 布尔值 bool，注意布尔值的 `True` 和 `False` 需要大写
- 空值，用 `None` 表示

对应强制转换方法：`int(), float(), str(), bool()`

`int()` 可以将一个字符串形式的数字转换成整数类型，注意字符串类型直接和整数类型比较会报错，`int()` 方法发现一个字符串不是合法数字时也会报错

整数和浮点数在计算机内的存储方式不同，整数计算永远是精确的，浮点数可能存在四舍五入的误差

**格式化**

用 `%` 实现格式化：

- %d 代表整数
- %s 代表字符串
- %f 代表浮点数
- %x 代表16进制整数
- %% 代表对 % 的转义

```python
# 字符串需要注意对转义字符 `\`,单行不转义字符 `r'...'` 以及多行不转义字符 `r'''...'''` 的使用
multiline = r'''"123"
你好
!'''

# 用 `%` 实现格式化
str2 = 'hello, %s%d%.2f' %('yango', 777, 3.6666)

# `range(n)` 生成一个[0, ..., n-1] 的整数序列
list = range(10)

# 字符串大写转小写 `str.lower()`
a = "HHH".lower()
```


### 赋值

python 是动态语言，所以赋值时不需要指定变量类型，甚至不需要像javascript 需要关键字，直接通过 `=` 就可以进行赋值

变量在一块内存中，数据在若干块内存中，**赋值实际上就是关联变量和数据的过程**

```python
sum = 0

# 在 python 中，全部是大写的变量名表示常量
WORD = "hello"
```


### encoded

产生不同编码方式的原因在于：用来处理各国文字所需的字节数和方式不同

编码演变过程

- `ASCII` 最早只有127个字母被编码到计算机内，包含大小写英文字母，数字和符号

- `Unicode` 则将所有的语言都统一到一套编码里面

> 这两种编码方式的主要区别在于：ACSII编码是一个字节，而Unicode通常是两个字节（如果遇到非常偏僻的字符，则需要四个字节）

- 新的问题又出现了：如果统一成Unicode编码，编码问题是消失了，但是如果文本全是英文的话，会比ASCII多占用近一倍的内存，在存储和传输上十分不划算，由此衍生出“可变长编码”--`UTF-8`

- `UTF-8`将一个Unicode字符根据不同的数字大小编码成1-6个字节

- 在计算机内存中，统一使用Unicode编码，当需要保存或传输时，则转变成UTF-8编码

python3 提供 `ord()` 和 `chr()` 用来获取字符的编码/转码对应的字符编码

> `ord()` 仅支持单个字符

`len(String)` 方法用来计算字符的长度

**key point**: 当源代码包含中文时，在保存源码时，需要制定其保存为 UTF-8，因此在python解释器读取源码时，为了让它以 UTF-8 编码，通常在文件开头写入以下代码


## dict && set

dict 即 dictionary，是一个map，类似 JavaScript 对象的概念，一个键值对的集合

通过 `in` 和 `get()` 方法来判断某一属性值是否在指定 dict 中，因为 python 中，如果 dict 中某个key不存在而直接使用的话，会报错

**dict中的key必须是不可变对象**

**dict中存放顺序和读取顺序无关**

对比list:

- dict 是以空间换时间，消耗更多的内存来减少检索时间

set

要创建一个 set，需要以一个 list 作为输入集合

set 是一组 key 的集合，不存放 value，且存放的key不重复，重复元素会被过滤

set 可以看作数学意义上的无序且不重复的集合，所以可以做交集，并集等运算


### methods

dict 合并 `dict1.update(dict2)`: 将 dict2 合并至 dict1 内


## 条件判断

在 python 中，通过 `if:, elif:, else:` 配合缩进来进行条件判断

注意，if 条件判断的简写，只要 x 为非零数值、非空字符串、非空list等，就判断为 True

```python
if x:
    print('True')
```

### 循环

python 中两种循环，一种 `for item in Array`，一种 `while`


## module

通过 `import ...` 或者 `from ... import ...` 关键字使用模块，通过 `moduleName.muduleFunction` 来调用模块内的方法

在模块作用域内，通过 `_` 关键字来标识 private 变量或者函数（这是不是说不能访问，而是约定从编程习惯上不要这么做）

通过 `pip || pip3` command 来安装模块，pip3 是出于 Mac 中同时存在 python2 和 python3 考虑

当我们引入一个模块时，python 会在指定路径下寻找，默认情况下，python 会搜索当前目录，所有已安装的内置模块以及第三方模块，其路径通过 `sys.path` 的 list 来维护


## 对象信息

获取对象引用的类型，属性以及方法


### 对象类型

`type()` 结合 `types` 通常用于判断基本类型

`type()` 方法返回对象对应的 class 类型

注意，对一个 class，它会返回 `<class 'type'>`，而对于一个 instance，它会返回 `<class '__main__.Superman'>` ，这个表示其父类

通过 `import types` 的 types 对象，可以用来判断一个对象是否是函数以及函数的基本信息，比如是基本函数还是生成器等


### 继承关系

`isinstance()` 通常用于判断 class 的继承关系，它会判断一个对象是否是该类型本身，或者位于该类型的父继承链上

还可以判断，一个变量是否是某些类型中的一种，例如 `isinstance((1,2,3), (tuple, list))`


### 属性和方法

`dir()` 返回一个 list，包含该对象所有的属性和方法

结合 `hasattr(obj, key), getattr(obj, key, defaultvalue), setattr(obj, key, value)` 可以直接操作一个对象的状态

一般能够直接获取对象属性的话，就直接获取，不需要调用 `setattr()` 方法


## 函数

[python 内置函数](http://docs.python.org/3/library/functions.html)

可以在 terminal 内通过 `help(abs)` 命令来查看abs方法的用法

函数也可以赋值给一个变量，代表对该方法的引用，相当于给该方法起了一个“别名”


### define

`def` 关键字（define function）用来声明一个函数

如果没有 return 语句，函数执行完毕会返回 None，`return None` 可简写为 `return`

通过 `pass` 关键字可以定义一个空函数，让代码先运行

一个好的习惯就是，优先检查参数的数据类型，通过 python内置方法 `isinstance()` 实现

可以通过 return 语句返回多个返回值，实际上还是一个tuple，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接受一个tuple，相当于 Javascript 的解构


### params

函数的参数，大致分为：

- 位置参数，表示调用时，传入的值按照位置顺序依次赋值
- 默认参数，类似 ES6 为参数设置一个默认值，如果调用函数时，无传参，则用默认值代替
- 可变参数，关键字为 `*`，在变量前添加，代表该参数为可变参数，可以传入任意个参数，在函数内部会被处理成 tuple，这样做的好处在于不用在函数调用时组装出一个 tuple 或者 list
- 关键字参数，关键字为 `**`，于可变参数类似，不过函数会解析成 dict，需要传入若干个键值对，如果传入一个 dict，则会在函数内部生成一份原 dict 的拷贝
- 命名关键字参数，需要一个特殊分隔符 `*`，`*` 后面的参数被视为命名的关键字参数，调用时必须传入 key，并且可以为某个属性设置 value

**注意**

1. 必选参数要放在默认参数前面，可以不按照顺序提供默认参数，此时需要指定 key

2. 默认参数必须指向不变对象，因为 python 函数在定义时，默认参数也是一个变量，并且指向设置的变量对象，每次调用函数时，如果改变了变量的值，实际上改变了变量对象，再次调用时，就不是初始值了，而是上次调用后的值，一般通过设置不变对象 `None` 来实现

3. 一个原则：在设置函数参数时，尽可能设计成不变对象

4. 对于可变参数，如果传入的是一个 list 或者 tuple，可以在调用时加上 `*` 关键字将其转换成可变参数

5. 可以利用关键字参数来区分必选字段和可选字段这样的用户输入场景

6. 传参可以组合，但是必须遵循顺序：必选参数 > 默认参数 > 可变参数/命名关键字参数 > 关键字参数


### 递归函数

递归函数就是在函数内部调用自身

在计算机中，函数调用是通过栈（stack）这种数据结构来实现的，每当函数调用，栈就会增加一层栈桢，每档一个函数返回，栈就会减少一个栈桢

由于栈本身是有大小限制的，所以使用递归函数要注意优化和防止栈溢出

解决递归调用栈溢出的方法就是通过**尾递归**，尾递归优化需要编译器或者解释器支持，优化点在于无论递归调多少次，栈桢都只占用一个，尾递归是指：

- 在函数返回时，调用自身
- return 语句不包含表达式

但是 python 解释器并没有对尾递归进行优化

