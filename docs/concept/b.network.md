# 计算机网络

> 研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序


## 进程通信
  
在操作系统中，进行通信的实际上是进程（process）而不是程序。一个进程可以被认为是运行在端系统的一个程序

当进程运行在相同的端系统(即同一电脑)上时，它们使用进程间的通信机制相互通信。进程间通信的规则由端系统上的操作系统确定

在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。发送进程生成报文并发送到网络中，接收进程接收这些报文并可能通过将报文发送回去进行响应

定义客户和服务器进程：在给定的一对进程之间的通信会话场景中，**发起通信** （即在该会话开始时发起与其他进程的联系）的进程被标识为客户，在会话开始时 **等待联系** 的进程是服务器

进程间通过套接字（socket）软件接口向网络发送或者接收报文

套接字是同一台主机内应用层和传输层之间的 **接口**，由于套接字是建立网络应用程序的可编程接口，因此套接字也被称为应用程序和网络之间的应用程序编程接口（API）

通过 ip（主机地址） 和 port（主机中接收进程标识符）来标识进程通信中的接收进程


## HTTP

:::tip
HTTP 使用 TCP 作为它的支撑运输协议
:::

Web 应用的底层协议是超文本传输协议（HyperText Transfer Protocol, HTTP），这是 Web 的核心，它定义了web客户与web服务器之间进行 http报文 交换的方式以及这些报文的结构（即如何交互和交互数据结构）

Web 页面由**对象**组成，一个对象就是一个文件，该文件可以是一个 .html文件，一个 .jpg图片等等，比如：一个 Web 页面包含1个 html 基本文件和2个 css 引用文件，则这个 Web 页面包含3个对象

![HTTP请求/响应](./assets/tcp.png)

- HTTP客户首先通过发起一个与服务器的**TCP连接请求**，一旦连接建立，该浏览器与服务器进程就可以通过套接字接口访问 TCP，然后客户和服务器从它的套接字发送或者接收 HTTP 报文

- 一旦客户向它的套接字发送了一个**HTTP请求报文**，该报文就脱离了客户控制并进入 TCP 控制，由于 TCP 为 HTTP 提供可靠数据传输服务，所以在客户和服务器交换报文的过程，不必担心数据丢失

- 这也体现了分层体系的 **最大优点** ：HTTP 协议不必担心数据丢失，也不必了解 TCP 从网络的数据丢失和乱序故障中恢复的细节

- HTTP 服务器 **不会** 保存关于客户的任何信息，所以 HTTP 是无状态协议，这意味着服务器不会因为刚刚为该用户提供了对象就不再响应，而是会重新发送该对象

### RTT

RTT指往返时间（Round-Trip Time），该时间指一个短分组从客户到服务器然后再返回客户所花费的时间

RTT = 分组时延 + 分组在中间路由器和交换机上的排队时延 + 分组处理时延

大致上说，一次 HTTP 请求/响应时间等于两次 RTT 加上服务器文件传输文件的时间

### HTTP请求报文

```
// 请求行，包含三个字段：请求方法，URL，HTTP版本
POST http://172.17.2.42/api/task/list-task-for-applicant http/1.1

// 首部行
// Host 指明了对象所在的主机，该字段提供的信息是 Web 代理高速缓存所要求的
Host: 172.17.2.42

// Connection 告诉服务器是否需要持续使用该连接，可取值 keep-alive 或者 close
Connection: keep-alive

// User-Agent 用来指明用户代理，即向服务器发送请求的浏览器类型
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3390.0 Safari/537.36

// Accept-Language 表示用户想要得到该对象的语言版本
Accept-Language: zh-CN,zh;q=0.9 
```

HTTP 请求报文的通用格式：请求行，首部行，空行，实体主体

HTTP 请求报文的第一行叫做请求行（request line），其后继的行叫做首部行（header line）

使用 GET 方法时，实体主体为空，使用 POST 方法时，才使用实体主体

### HTTP响应报文

```
// 状态行包含三个字段：协议版本，状态码和相应的状态信息
HTTP/1.1 200 OK

// 首部行
// Server 指示该报文是由 nginx/1.10.1 服务器产生的
Server: nginx/1.10.1

// Date 指示服务器从它的文件系统找到该对象，插入到响应报文，并且发送该响应报文的日期和时间
Date: Sun, 08 Apr 2018 08:47:04 GMT

// Content-Type 指示了实体主体中的对象类型
Content-Type: application/json;charset=UTF-8

// Connection 告诉客户是否需要持续使用该连接，可取值 keep-alive 或者 close
Connection: keep-alive

// Last-Modified 最后修改日期和时间，对于本地客户和代理服务器上的对象缓存来说很重要
Last-Modified: Sun, 08 Apr 2018 08:46:04 GMT

entity body data...
```

HTTP 响应报文的通用格式：状态行，首部行，空行，实体主体

实体主体是响应报文的主要部分，它包含了所请求的对象本身


## TCP连接方式

客户到服务器的每个请求/响应是经单独的 TCP 连接发送，则该应用程序使用非持续连接（non-persistent connection）,每个 TCP 连接在服务器发送一个对象后关闭，即每个 TCP 连接只传输一个请求报文和一个响应报文

由此可见，非持续连接的缺点在于：

- 必须为每一个请求对象建立和维护一个全新的连接，对于每个这样的连接，在客户和服务器都要分配 TCP 的缓冲区和保持 TCP 变量
- 每个对象都要经受两倍 RTT 的交付时延

客户到服务器的所有请求/响应是经相同的 TCP 连接发送，则该应用程序使用持续连接（presistent connection）。即服务器在发送响应后保持该 TCP 连接打开，在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传输

HTTP 在其默认方式下使用持续连接，通过 `Connection: keep-alive` 标识

